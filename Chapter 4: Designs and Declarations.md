### Item 18. Make interfaces easy to use correctly and hard to use incorrectly.

- 좋은 인터페이스는 제대로 쓰기엔 쉬우며 엉터리로 쓰기엔 어렵습니다. 인터페이스를 만들 때는 이 특성을 지닐 수 있도록 고민하고 또 고민합시다.
- 인터페이스의 올바른 사용을 이끄는 방법으로는 인터페이스 사이의 일관성 잡아주기, 그리고 기본 제공 타입과의 동작 호환성응 유지하기가 있습니다.
- 사용자의 실수를 방지하는 방법으로는 새로운 타입 만들기, 타입에 대한 연산을 제한하기, 객체의 값에 대해 제약 걸기, 자원 관리 작업을 사용자 책임으로 놓지 않기가 있습니다.
- tr1::shared_ptr은 사용자 정의 삭제자를 지원합니다. 이 특징 때문에 tr1::shared_ptr은 교차 DLL 문제를 막아 주며, 뮤텍스 등을 자동으로 잠금 해제하는 데 쓸 수 있습니다.
    - 교차 DLL 문제: 객체 생성 시에 어떤 동적 링크 라이브러리(DLL)의 new를 썼는데 그 객체를 해제 할 때는 이전의 DLL과 다른 DLL에 있는 delete를 써서 발생하는 문제

### Item 19. Treat class design as type design

- 클래스 설계는 타입 설계입니다. 새로운 타입을 정의하기 전에, 다음의 모든 고려사항을 빠짐없이 점검해 보세요.
    - 새로 정의한 타입의 객체 생성 및 소멸은 어떻게 이루어져야 하는가?
        - 이 부분에 따라 클래스의 생성자 및 소멸자의 설계가 바뀝니다. 그뿐 아니라 메모리 할당 연산자 함수를 오버로딩하는 경우에는 이들 연산자 함수의 설계에도 영향을 미칩니다.
    - 객체 초기화는 객체 대입과 어떻게 달라야 하는가?
        - 생성자와 대입 연산자의 동작 및 둘 사이의 차이점을 결정짓는 요소입니다.
    - 새로운 타입으로 만든 객체가 값에 의해 전달되는 경우에 어떤 의미를 줄 것인가?
        - 여기서 잊으면 안되는 중요한 사실은 ‘값에 의한 전달’을 구현하는 쪽은 바로 복사생성자라는 것입니다.
    - 새로운 타입이 가질 수 있는 적법한 값에 대한 제약은 무엇으로 잡을 것인가?
        - 전부는 아니지만, 클래스의 데이터 멤버의 몇 가지 조합 값만은 반드시 유효해야 합니다. 이런 조합을 가리켜 클래스의 불변속성이라고 하며, 클래스 차원에서 지켜주어야 하는 부분입니다. 이 불변속성에 따라 클래스 멤버 함수 안에서 해 주어야 할 에러 점검 루틴이 좌우되는데, 특히 생성자, 대입 연산자, 각종 “쓰기” 함수는 불변속성에 많이 좌우됩니다. 그뿐 아니라 불변속성은 함수가 발생시키는 예외에도 영향을 미치며, 예외 지정을 쓴다면 그 부분에도 영향을 줍니다.
    - 기존의 클래스 상속 계통망에 맞출 것인가?
        - 이미 갖고 있는 클래스로부터 상속을 시킨다고 하면, 클래스의 설계는 이들 클래스에 의해 제약을 받게 됩니다. 특히 멤버 함수의 가상성 여부가 가장 큰 요인입니다. 만약 직접 만든 클래스를 다른 클래스들이 상속할 수 있게 만들자고 결정 했다면, 이에 따라 멤버 함수의 가상 함수 여부가 결정됩니다.
    - 어떤 종류의 타입 변환을 허용할 것인가?
        - 암시적 타입 변환과 명시적 타입 변환중 허용할 타입 변환을 정합니다.
    - 어떤 연산자와 함수를 두어야 의미가 있을까?
        - 클래스 안에 선언할 멤버 함수가 여기서 결정됩니다. 멤버 함수로 적당한 함수와 그렇지 않은 함수가 있을 것입니다.
    - 표준 함수들 중 어떤 것을 허용하지 말 것인가?
        - 클래스 안에 선언할 멤버 함수가 여기서 결정됩니다. 멤버 함수로 적당한 함수와 그렇지 않은 함수가 있을 것입니다.
    - 새로운 타입의 멤버에 대한 접근권한을 어느 쪽에 줄 것인가?
        - 어떤 클래스 멤버를 public, protected, private 영역에 둘 것인가를 결정하는데 도움을 주게 될 질문입니다. 또한 friend로 만들어야 할 클래스 및 함수를 결정하는 것은 물론이고 한 클래스를 다은 클래스에 중첩시켜도 되는가에 대한 결정을 내리는 데도 이 질문이 도움이 될 것입니다.
    - 선언되지 않은 인터페이스 로 무엇을 둘 것인가?
        - 만든 타입이 제공할 보장이 어떤 종류일까에 대한 질문으로서, 보장할 수 있는 부분은 수행 성능 및 예외 안전성 그리고 자원 사용입니다. 이들에 대해 여러분이 보장하겠다고 결정한 결과는 클래스 구현에 있어서 제약으로 작용하게 됩니다.
    - 새로 만드는 타입이 얼마나 일반적인가?
        - 정의하는 클래스가 타입 하나가 아니라 동일 계열의 타입군 전체일지도 모릅니다. 만일 그렇다면 새로운 클래스가 아니라 새로운 클래스 템플릿을 정의해야 할 것입니다.
    - 정말로 꼭 필요한 타입인가?
        - 기존의 클래스에 대해 기능 몇 개가 아쉬워서 파생 클래스를 새로 만들기 보다는, 차라리 간단하게 비멤버 함수라든지 템플릿을 몇 개 더 정의하는 편이 낫습니다.

### Item 20. Prefer pass-by-reference to const to pass-by-value.

- 값에 의한 전달 보다는 상수 객체 참조자에 의한 전달을 선호합ㄴ시다. 대체적으로 효율적일 뿐만 아니라 복사 손실 문제까지 막아줍니다.
- 이번 항목에서 다룬 법칙은 기본제공 타입 및 STL 반복자, 그리고 함수 객체 타입에는 맞지 않습니다. 이들에 대해서는 값에 의한 전달이 더 적절합니다.

### Item 21. Don’t try to return a reference when you must return an object.

- 지역 스택 객체에 대한 포인터나 참조자를 반환하는 일, 혹은 힙에 할당된 객체에 대한 참조자를 반환하는 일, 또는 지역 정적 객체에 대한 포인터나 참조자를 반환하는 일은 그런 객체가 두 개 이상 필요해질 가능성이 있다면 절대로 하지 마세요.

### Item 22. Declare data members private.

- 데이터 멤버는 private 멤버로 선언합시다. 이를 통해 클래스 제작자는 문법적으로 일관성 있는 데이터 접근 통로를 제공할 수 있고, 필요에 따라서는 세밀한 접근 제어도 가능하며, 클래스의 불변속성을 강화할 수 있을 뿐 아니라, 내부 구현의 융통성도 발휘할 수 있습니다.
- protected는 public보다 더 많이 보호 받고 있는 것이 절대로 아닙니다.
    - 왜냐하면 파생 클래스에서는 여전히 protected 데이터 멤버에 직접 접근할 수 있기 때문입니다.

### Item 23. Declare non-member non-friend functions to member functions.

- 멤버 함수보다는 비멤버 비프렌드 함수를 자주 쓰도록 합시다. 캡슐화 정도가 높아지고, 패키징 유연성도 커지며, 기능적인 확장성도 늘어납니다.
    - 캡슐화 정도가 높아진다: 비멤버 비프렌드 함수는 private 데이터 멤버에 접근하는 함수의 수를 늘리지 않기 때문입니다.
    - 패키징 유연성이 커진다: 반드시 사용해야 하는 핵심 기능들을 멤버함수로 만들어 하나의 헤더에 선언해 두고, 나머지 부가기능들은 같은 네임스페이스 내의 다른 헤더에 기능별로 분류하여 비멤버 비프렌드 함수로 선언해 두면 사용자는 필수 헤더와 사용하고자 하는 기능이 포함된 헤더만 include하여 라이브러리를 사용할 수 있다.
    - 기능적인 확장성이 높다: 사용자가 기능 확장을 원하는 클래스와 동일한 네임스페이스 안에 편의를 위한 비멤버 비프렌드 함수를 추가로 정의해 넣을 수 있다. 단, std 네임스페이스에는 사용자가 내용을 추가해선 안된다.

### Item 24. Declare non-member functions when type conversions should apply to all parameters.

- 어떤 함수에 들어가는 모든 매개변수에 대해 타입 변환을 해 줄 필요가 있다면, 그 함수는 비 멤버이어야 합니다.

### Item 25. Consider support for a non-throwing swap.

- std::swap이 여러분의 타입에 대해 느리게 동작할 여지가 있다면 swap 멤버 함수를 제공합시다. 이 멤버 swap은 예외를 던지지 않도록 만듭니다.
- 멤버 swap을 제공했으면, 이 멤버를 호출하는 비멤버 swap도 제공합시다. 클래스에 대해서는, std::swap도 특수화해 둡시다.
- 사용자 입장에서 swap을 호출할 때는, std::swap에 대한 using 선언을 넣어 준 후에 네임스페이스 한정 없이 swap을 호출합니다.
- 사용자 정의타입에 대한 std 템플릿을 완전 특수화 하는 것은 가능합니다. 그러나 std에 어떤 것이 라도 새로 추가하려고 들지는 마십시오.
