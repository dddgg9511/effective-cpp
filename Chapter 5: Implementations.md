### Item 26. Postpone variable definition as long as possible.

- 변수 정의는 늦출 수 있을때까지 늦춥시다. 프로그래밍이 더 깔끔해지며 효율도 좋아집니다.

### Item 27.Minimize casting

- 다른 방법이 가능하다면 캐스팅은 피하십시오. 특히 수행 성능에 민감한 코드에서는 dynamic_cast는 몇 번이고 다시 생각하십시오. 설계 중에 캐스팅이 필요해졌다면, 캐스팅을 쓰지 않는 다른 방법을 시도해 보십시오.
- 캐스팅이 어쩔 수 없이 필요하다면, 함수 안에 숨길 수 있도록 해보십시오. 이렇게 하면 최소한 사용자는 자신의 코드에 캐스팅을 넣지 않고 이 함수를 호출할 수 있게 됩니다.
    - 캐스팅을 해야 하는 코드를 내부 함수 속에 몰아 놓고, 그 안에서 일어나는 천한 일들은 이 함수를 호출하는 외부에서 알 수 없도록 인터페이스로 막아두는 식으로 해결하면 됩니다.
- 구형 스타일의 캐스트를 쓰려거든 C++ 스타일의 캐스트를 선호하십시오. 발견하기도 쉽고, 설계자가 어떤 역할을 의도했는지가 더 자세하게 드러납니다.
    - C++의 캐스트 연산자
        - const_cast: 객체의 상수성을 없애는 용도로 사용합니다.
        - dynamic_cast: 안전한 다운 캐스팅을 할 때 사용하는 연산자입니다. 신경쓰일 정도로 런타임 비용이 높아 쓰지 않는 것이 좋습니다.
        - reinterpret_cast: 포인터를 int로 바꾸는 등 의 하부 수준 캐스팅을 위한 연산자로서, 이것의 작용 결과는 구현환경에 의존적입니다. 이런 캐스트는 하부 수준 코드 외에 는 거의 없어야 합니다.
        - static_cast: 암시적 변환을 강제로 진행할 때 사용합니다.

### Item 28. Avoid returning handles to object internals.

- 어떤 객체의 내부요소에 대한 핸들을 반환하는 것은 되도록 피하세요. 캡슐화 정도를 높이고, 상수 멤버 함수가 객체의 상수성을 유지한 채로 동작할 수 있도록 하며, 무효참조 핸들이 생기는 경우를 최소화할 수 있습니다.

### item 29. Strive for exception-safe code.

- 예외 안전성을 갖춘 함수는 실행 중 예외가 발생되더라도 자원을 누출시키지 않으며 자료구조를 더럽힌 채로 내버려 두지 않습니다. 이런 함수들이 제공할 수 있는 예외 안전성 보장은 기본적인 보장, 강력한 보장, 예외 금지 보장이 있습니다.
    - 예외 안전성을 가진 함수라면 예외가 발생할 때 이렇게 동작해야 합니다.
        - 자원이 새도록 만들지 않습니다.
        - 자료구조가 더럽혀지는 것을 허용하지 않습니다.
    - 예외 안전성을 갖춘 함수는 아래의 세 가지 보장 중 하나를 제공합니다.
        - 기본적인 보장: 함수 동작 중에 예외가 발생하면, 실행 중인 프로그램에 관련 된 모든 것들을 유효한 상태로 유지하겠다는 보장입니다. 어떤 객체나 자료구조도 더럽혀지지 않으며, 모든 객체의 상태는 내부적으로 일관성을 유지하고 있습니다. 하지만 프로그램의 상태가 정확히 어떠한지는 예측이 안 될 수 도 있습니다.
        - 강력한 보장 : 함수 동작 중에 예외가 발생하면, 프로그램의 상태를 절대로 변경하지 않겠다는 보장입니다. 이런 함수를 호출하는 것은 원자적인 동작이라고 할 수 있습니다. 호출이 성공하면 마무리까지 완벽하게 성공하고, 호출이 실패하면 함수 호출이 없었던 것처럼 프로그램의 상태가 되돌아갑니다.
        - 예외 불가 보장: 예외를 절대로 던지지 않겠다는 보장입니다.
    - 현실적으로 대부분의 함수에 있어서 기본적인 보장과 강력한 보장 중 하나를 고르게 됩니다.
    - 강력한 예외 안전성 보장은 복사 후 맞바꾸기 방법을 써서 구현할 수 있지만, 모든 함수에 대해 강력한 보장이 실용적인 것은 아닙니다.
        - 복사 후 맞바꾸기란 현재 객체의 복사본을 만들고 복사본을 수정한 뒤 수정에 성공한 경우 현재의 객체와 수정된 복사본을 바꿔치기 하는 것입니다.
    - 어떤 함수가 제공하는 예외 안전성 보장의 강도는, 그 함수가 내부적으로 호출하는 함수들이 제공하는 가장 약한 보장을 넘지 않습니다.

### item 30. Understand the ins and outs of inlining.

- 함수 인라인은 작고, 자주 호출되는 함수에 대해서만 하는 것으로 묶어둡시다. 이렇게 하면 디버깅 및 라이브러리 바이너리 업그레이드가 용이해지고, 자칫 생길 수 있는 코드 부풀림 현상이 최소화되며, 프로그램의 속력이 더 빨라질 수 있는 여지가 최고로 많아집니다.
    - 생성자와 소멸자는 인라인으로 만들기에 그리 좋지 않은 함수입니다. 왜냐하면 생성자나 소멸자내에는 부모 클래스의 생성자나 소멸자, 그리고 멤버 객체들의 생성자나 소멸자를 호출하는 코드가 포함되기 때문입니다.
    - 함수 템플릿이 대개 헤더 파일에 들어간다는 일반적인 부분만 생각해서 이들을 inline으로 선언하면 안됩니다.

### Item 31. Minimize compilation dependencies between files.

- 컴파일 의존성을 최소화하는 작업의 배경이 되는 가장 기본적인 아이디어는 정의 대신 선언에 의존하게 만들자는 것입니다. 이 아이디어에 기반한 두 가지 접근 방법은 핸들 클래스와 인터페이스 클래스 입니다.
    - 객체 참조자 및 포인터로 충분한 경우에는 객체를 직접 쓰지 않습니다.
        - 어떤 타입에 대한 참조자 및 포인터를 선언할 때는 그 타입의 선언부만 필요합니다. 반면, 어떤 타입의 객체를 정의할 때는 그 타입의 정의가 준비되어 있어야 합니다.
    - 할 수 있으면 클래스 정의 대신 클래스 선언에 최대한 의존하도록 만듭시다.
        - 어떤 클래스를 사용하는 함수를 선언할 때는 그 클래스의 정의를 가져오지 않아도 됩니다. 심지어 그 클래스 객체를 값으로 전달하거나 반환하더라도 클래스 정의가 필요 없습니다.
    - 선언부와 정의부에 대해 별도의 헤더 파일을 제공합니다.
        - 클래스를 둘로 쪼개자 라는 지침을 제대로 쓸 수 있도록 하려면 헤더 파일이 짝으로 있어야 합니다. 하나는 선언부를 위한 헤더 파일이고, 또 하나는 정의부를 위한 헤더 파일이겠지요. 당연한 이야기이겠지만 이 두 파일은 관리도 짝 단위로 해야 합니다. 한쪽에서 어떤 선언이 바뀌면 다른 쪽도 똑같이 바뀌어야 한다는 거죠. 그렇기 때문에 라이브러리 사용자쪽에서는 전방 선언 대신에 선언부 헤더 파일을 항상 #include 해야 할 것이고, 라이브러리 제작자 쪽에서는 헤더 파일 두 개를 짝지어 제공하는 일을 잊으면 안됩니다.
    - 라이브러리 헤더는 그 자체로 모든 것을 갖추어야 하며 선언부만 갖고 있는 형태여야 합니다. 이 규칙은 템플릿이 쓰이거나 쓰이지 않거나 동일하게 적용합시다.
