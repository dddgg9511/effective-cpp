### Item 5. Know what functions C++ silently writes and calls

- 컴파일러는 경우에 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있습니다.

### Item 6. Explicitly disallow the use of compiler-generated functions you do not want.

- 컴파일러에서 자동으로 제공하는 기능을 허용하지 않으려면 대응되는 멤버 함수를 private으로 선언한 후에 구현은 하지 않은 채로 두십시오.

### Item 7. Declare destructors virtual in polymorphic base classes.

- 다형성을 가진 기본 클래스에는 반드시 가상 소멸자를 선언해야 합니다. 즉, 어떤 클래스가 가상 함수를 하나라도 갖고 있으면, 이 클래스의 소멸자도 가상 소멸자이어야 합니다.
    - 기본 클래스의 소멸자가 가상이 아닌 경우, 파생 클래스의 객체를 기본 클래스의 포인터에 담아 소멸시킬때, 기본 클래스의 소멸자만 호출되어 자원이 누출될 수 있습니다.

### Item 8. Prevent exceptions from leaving destructors.

- 소멸자에서는 예외가 빠져나가면 안 됩니다. 만약 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외든지 소멸자에서 모두 받아낸 후에 삼켜버리든지 프로그램을 끝내던지 해야합니다.

발생한 예외를 처리하기 위해 스택 되감기를 하는 도중, 또 다른 예외가 발생하면 상황에 따라 프로그램이 종료되던지, 정의되지 않은 동작을 보이게 됩니다. 따라서 소멸자에서 예외가 빠져나가도록 두면 안됩니다.

- 어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 할 필요가 있다면, 해당 연산을 제공하는 함수는 반드시 보통의 함수이어야 합니다.

### Item 9. Never call virtual functions during construction or destruction.

- 생성자 혹은 소멸자 안에서 가상 함수를 호출하지 마세요. 가상 함수라고 해도, 지금 실행중인 생성자나 소멸자에 해당되는 클래스의 파생 클래스 쪽으로는 내려가지 않으니까요.

### Item 10. Have assignment operators return a reference to *this.

- 대입 연산자는 *this의 참조자를 반환하도록 만드세요. 이것은 단순 대입형 연산자 뿐만 아니라, 모든 형태의 대입 연산자에서 지켜져야 합니다. 이러한 관례를 따르지 않아도 컴파일은 되지만, 관례를 따르는 편이 여러 모로 좋습니다. 헷갈린다면, int의 작동 원리대로 만드세요.

### Item 11. Handle assignment to self in operator=.

- operator=을 구현할 때, 어떤 객체가 그 자신에 대입되는 경우를 제대로 처리하도록 만듭시다. 원본 객체와 복사대상 객체의 주소를 비교해도 되고, 문장의 순서를 적절히 조정할 수도 있으며, 복사 후 맞바꾸기 기법을 써도 됩니다.
- 두 개 이상의 객체에 대해 동작하는 함수가 있다면, 이 함수에 넘겨지는 객체들이 사실 같은 객체인 경우에 정확하게 동작하는지 확인해 보세요.

### Item 12. Copy all parts of an object.

- 객체 복사 함수는 주어진 객체의 모든 데이터 멤버 및 모든 기본 클래스 부분을 빠뜨리지 말고 복사해야 합니다.
- 클래스의 복사 함수 두 개(복사 생성자, 복사 대입 연산자)를 구현할 때, 한 쪽을 이용해서 다른 쪽을 구현하려는 시도는 절대로 하지 마세요. 그 대신 공통된 동작을 제3의 함수에 분리해 놓고 양쪽에서 이것을 호출하게 만들어서 해결합니다.
