# Chapter 1: Accustoming Yourself to C++.
## Item 1. View C++ as a federation of languages.
- C++을 사용한 효과적인 프로그래밍 규칙은 경우에 따라 달라집니다. 그 경우란, 바로 C++의 어떤 부분을 사용하느냐 입니다.
C++은 다음 네 가지 부분으로 나누어 생각할 수 있습니다.
- C언어에서 물려받은 부분
- 객체 지향 개념의 C++
- 템플릿 C++
- STL
## Item 2: Prefer const, enums, and inlines to #defines.
- 전처리기보다는 compiler를 선호합시다.
- 단순한 상수를 쓸 때는, #define보다 const 객체 혹은 enum을 우선 생각합니다.
- 함수처럼 쓰이는 매크로를 만들려면, #define 매크로보다 인라인 함수를 우선 생각합시다.
## Item 3: Use const whenever possible.
- Const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 줍니다. Const는 어떤 유효범위에 있는 객체에도 붙을 수 있으며, 함수 매개변수 및 반환타입에도 붙을 수 있으며, 멤버 함수에도 붙을 수 있습니다.
- 컴파일러 쪽에서 보면 비트수준 상수성을 지켜야 하지만, 개념적인 상수성을 사용해서 프로그래밍 해야합니다.
  - 비트수준 상수성: 어떤 객체의 멤버 함수가 객체의 정적 멤버를 제외한 데이터 멤버를 건드리지 않은 경우에만 그 멤버 함수가 'const' 임을 인정함
  - 개념적인 상수성: 상수 멤버 함수도 객체의 일부 몇 비트를 바꿀 수 있되 사용자 측에서 알아채지 못하도록(객체의 상태에 영향을 주지 않도록) 해야 함
- 상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같이 구현되어 있을 경우에는 코드 중복을 피하는 것이 좋은데, 이때 비상수 버전이 상수 버전을 호출하도록 만드세요.
## Item 4: Make sure that objects are initialized before they’re used.
- 기본제공 타입의 객체는 직접 손으로 초기화합니다. 경우에 따라서 저절로 되기도 하고 안 되기도 하기 때문입니다.
- 생성자에서는, 데이터 멤버에 대한 대입문을 생성자 본문 내부에 넣는 방법으로 초기화하지 말고 멤버 초기화 리스트를 즐겨 사용합시다. 그리고 초기화 리스트에 데이터 멤버를 나열할 때는 클래스에 각 데이터 멤버가 선언된 순서와 똑같이 나열합시다.
- 여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제는 피해서 설계해야 합니다. 비지역 정적 객체를 지역 정적객체로 바꾸면 됩니다.

